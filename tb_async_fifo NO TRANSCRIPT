//NO TRANSCRIPT ONLY BASIC PASS FAIL
`timescale 1ns/1ps

module tb_async_fifo;

  localparam int DATA_WIDTH = 8;
  localparam int DEPTH      = 16;

  // -----------------------
  // DUT signals
  // -----------------------
  logic wclk, rclk;
  logic wrst, rrst;

  logic                 w_valid;
  logic [DATA_WIDTH-1:0] w_data;
  logic                 w_ready;

  logic                 r_ready;
  logic                 r_valid;
  logic [DATA_WIDTH-1:0] r_data;

  // -----------------------
  // DUT
  // -----------------------
  async_fifo #(
    .DATA_WIDTH(DATA_WIDTH),
    .DEPTH(DEPTH)
  ) dut (
    .wclk(wclk),
    .wrst(wrst),
    .w_valid(w_valid),
    .w_data(w_data),
    .w_ready(w_ready),

    .rclk(rclk),
    .rrst(rrst),
    .r_ready(r_ready),
    .r_valid(r_valid),
    .r_data(r_data)
  );

  // -----------------------
  // Clocks (different rates)
  // -----------------------
  initial begin wclk = 0; forever #5  wclk = ~wclk; end  // 100 MHz
  initial begin rclk = 0; forever #7  rclk = ~rclk; end  // ~71 MHz

  // -----------------------
  // Reset
  // -----------------------
  initial begin
    wrst = 1; rrst = 1;
    w_valid = 0; w_data = '0;
    r_ready = 0;

    #20;
    wrst = 0; rrst = 0;
  end
initial begin
  $display("TB START time=%0t", $time);
  #100;
  $display("TB HIT 100ns time=%0t", $time);
  #900;
  $display("TB FINISH time=%0t", $time);
  $finish;
end

  // ============================================================
  // Transaction
  // ============================================================
  typedef enum bit {DO_WRITE, DO_READ} op_t;

  class fifo_transaction;
    op_t op;
    bit [DATA_WIDTH-1:0] data;  // used for write; read monitors fill observed data
  endclass

  // ============================================================
  // Generator
  // ============================================================
  class fifo_generator;
    mailbox #(fifo_transaction) gen2wdrv;
    mailbox #(fifo_transaction) gen2rdrv;

    int num_writes;
    int num_reads;

    function new(mailbox #(fifo_transaction) wmb,
                 mailbox #(fifo_transaction) rmb);
      gen2wdrv = wmb;
      gen2rdrv = rmb;
    endfunction

    task run();
      fifo_transaction tr;

      // generate writes: data = 0,1,2,3,...
      for (int i = 0; i < num_writes; i++) begin
        tr = new();
        tr.op   = DO_WRITE;
        tr.data = i[DATA_WIDTH-1:0];
        gen2wdrv.put(tr);
      end

      // generate reads (same count)
      for (int i = 0; i < num_reads; i++) begin
        tr = new();
        tr.op = DO_READ;
        gen2rdrv.put(tr);
      end
    endtask
  endclass

  // ============================================================
  // Write Driver
  // ============================================================
  class write_driver;
    mailbox #(fifo_transaction) gen2wdrv;

    function new(mailbox #(fifo_transaction) mb);
      gen2wdrv = mb;
    endfunction

    task run();
      fifo_transaction tr;

      // wait out reset
      @(negedge wrst);

      forever begin
        gen2wdrv.get(tr);

        // drive until accepted (w_valid && w_ready on wclk)
        do begin
          @(posedge wclk);
          w_valid <= 1'b1;
          w_data  <= tr.data;
        end while (!w_ready);

        // deassert after accept
        @(posedge wclk);
        w_valid <= 1'b0;
      end
    endtask
  endclass

  // ============================================================
  // Read Driver
  // ============================================================
  class read_driver;
    mailbox #(fifo_transaction) gen2rdrv;

    function new(mailbox #(fifo_transaction) mb);
      gen2rdrv = mb;
    endfunction

    task run();
      fifo_transaction tr;

      @(negedge rrst);

      forever begin
        gen2rdrv.get(tr);

        // pulse r_ready until a transfer happens (r_valid && r_ready on rclk)
        do begin
          @(posedge rclk);
          r_ready <= 1'b1;
        end while (!r_valid);

        // deassert after accept
        @(posedge rclk);
        r_ready <= 1'b0;
      end
    endtask
  endclass

  // ============================================================
  // Monitors
  // ============================================================
  class input_monitor; // watches writes
    mailbox #(bit [DATA_WIDTH-1:0]) mon2sb;

    function new(mailbox #(bit [DATA_WIDTH-1:0]) mb);
      mon2sb = mb;
    endfunction

    task run();
      @(negedge wrst);
      forever begin
        @(posedge wclk);
        if (w_valid && w_ready) begin
          mon2sb.put(w_data);
        end
      end
    endtask
  endclass

  class output_monitor; // watches reads
    mailbox #(bit [DATA_WIDTH-1:0]) mon2sb;

    function new(mailbox #(bit [DATA_WIDTH-1:0]) mb);
      mon2sb = mb;
    endfunction

    task run();
      @(negedge rrst);
      forever begin
        @(posedge rclk);
        if (r_valid && r_ready) begin
          mon2sb.put(r_data);
        end
      end
    endtask
  endclass

  // ============================================================
  // Scoreboard (FIFO order check)
  // ============================================================
  class fifo_scoreboard;
    mailbox #(bit [DATA_WIDTH-1:0]) in_mb;
    mailbox #(bit [DATA_WIDTH-1:0]) out_mb;

    bit [DATA_WIDTH-1:0] exp_q[$];
    int pass_cnt, fail_cnt;

    function new(mailbox #(bit [DATA_WIDTH-1:0]) inmb,
                 mailbox #(bit [DATA_WIDTH-1:0]) outmb);
      in_mb  = inmb;
      out_mb = outmb;
      pass_cnt = 0;
      fail_cnt = 0;
    endfunction

    task run();
      bit [DATA_WIDTH-1:0] d;

      fork
        // collect expected (writes)
        forever begin
          in_mb.get(d);
          exp_q.push_back(d);
        end

        // check actual (reads)
        forever begin
          bit [DATA_WIDTH-1:0] got, exp;
          out_mb.get(got);

          if (exp_q.size() == 0) begin
            $display("SB FAIL: read with no expected data. got=%0d", got);
            fail_cnt++;
          end else begin
            exp = exp_q.pop_front();

//$display("SB CHECK exp=%0d got=%0d", exp, got);


            if (got !== exp) begin
              $display("SB FAIL: exp=%0d got=%0d", exp, got);
              fail_cnt++;
            end else begin
              pass_cnt++;
            end
          end
        end
      join_none
    endtask
  endclass


  // ============================================================
  // Build + run
  // ============================================================
  mailbox #(fifo_transaction) gen2wdrv = new();
  mailbox #(fifo_transaction) gen2rdrv = new();
  mailbox #(bit [DATA_WIDTH-1:0]) in_mon_mb  = new();
  mailbox #(bit [DATA_WIDTH-1:0]) out_mon_mb = new();

  fifo_generator   gen;
  write_driver     wdrv;
  read_driver      rdrv;
  input_monitor    imon;
  output_monitor   omon;
  fifo_scoreboard  sb;

  initial begin
    gen  = new(gen2wdrv, gen2rdrv);
    wdrv = new(gen2wdrv);
    rdrv = new(gen2rdrv);
    imon = new(in_mon_mb);
    omon = new(out_mon_mb);
    sb   = new(in_mon_mb, out_mon_mb);

    // simple proof: write N, read N
    gen.num_writes = 50;
    gen.num_reads  = 50;

    fork
      gen.run();
      wdrv.run();
      rdrv.run();
      imon.run();
      omon.run();
      sb.run();
    join_none

wait (sb.pass_cnt + sb.fail_cnt == gen.num_reads);
$display("DONE: pass=%0d fail=%0d", sb.pass_cnt, sb.fail_cnt);
$finish;


    // end condition: wait until scoreboard saw all reads
    wait (sb.pass_cnt + sb.fail_cnt == gen.num_reads);

    $display("DONE: pass=%0d fail=%0d", sb.pass_cnt, sb.fail_cnt);
    if (sb.fail_cnt == 0) $display("TEST PASS");
    else                  $display("TEST FAIL");

    #20;
    $finish;
  end

endmodule
